package com.scrollList {	import com.lucee.iosclient.views.views.components.DeviceMenuButton;	import com.MemoryTracker;	import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.plugins.ThrowPropsPlugin;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.utils.Timer;	import flash.utils.getTimer;	// import flash.text.*;	public class ScrollList extends MovieClip {		public var isMoving : Boolean = false;		// used to determine finger move in pixels		public var mouseDownY : Number;		public var mouseUpY : Number;		public var tolerance : int = 20;		private var bounds : Rectangle;		private var bg : Sprite;		private var scrollList : Sprite;		private var t1 : uint, t2 : uint, y1 : Number, y2 : Number, yOverlap : Number, yOffset : Number, _w : int, _h : int, _itemh : int, _defaultcol : int, _hicol : int;		private var scrollMask : Shape;		private var scrollBar : MovieClip;		private var scrollBarHeight : Number;		private var barMaxDistance : Number;		private var listEndY : Number;		private var touchTimer : Timer;		private var selectedButton : ScrollListItem;		public function ScrollList(w : int, h : int, itemh : int, defaultcol : int, hicol : int) {			bounds = new Rectangle(0, 0, w, h);			_w = w;			_h = h;			_defaultcol = defaultcol;			_hicol = hicol;			_itemh = itemh;			scrollList = new Sprite();			addEventListener(Event.ADDED_TO_STAGE, init, false, 0, true);			// this.addEventListener(Event.REMOVED, destroy, false, 0, true);		}		private function init(e : Event) : void {			trace('init: ' + (init));			MemoryTracker.track(scrollList, "list scrollList");// remove when done testing			addChild(scrollList);			scrollMask = new Shape();			MemoryTracker.track(scrollMask, "list scrollMask");// remove when done testing//			setupList(scrollList, bounds);			scrollList.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);			// this timer controls the amount of time taken to trigger a touch.			touchTimer = new Timer(200);			MemoryTracker.track(touchTimer, "list touchTimer");// remove when done testing			// used for testing			/*			tf = new TextField();			tf.width = w;			tf.y = h + 20;						tf.defaultTextFormat = new TextFormat("_sans", 12);			tf.multiline = tf.wordWrap = true;			tf.selectable = false;			tf.autoSize = TextFieldAutoSize.LEFT;			addChild(tf);*/			createScrollBar();		}		private function createScrollBar() : void {			if (!scrollBar) {				scrollBar = new MovieClip();				MemoryTracker.track(scrollBar, "list scrollBar");// remove when done testing				addChild(scrollBar);			}			scrollBar.x = (scrollList.x + bounds.width) - 5;			scrollBar.graphics.clear();			// calculate the height of the scroll bar			if (scrollMask.height < scrollList.height) {				scrollBarHeight = scrollMask.height / scrollList.height * scrollMask.height;				scrollBar.graphics.beginFill(0x505050, .8);				scrollBar.graphics.drawRoundRect(0, 0, 4, (scrollBarHeight), 6, 6);				scrollBar.graphics.endFill();				scrollBar.alpha = 0;			}			barMaxDistance = scrollMask.height - scrollBar.height;		}		function mouseDownHandler(e : MouseEvent) : void {			isMoving = false;			TweenLite.killTweensOf(scrollList);			y1 = y2 = scrollList.y;			yOffset = this.mouseY - scrollList.y;			yOverlap = Math.max(0, scrollList.height - bounds.height);			t1 = t2 = getTimer();			scrollList.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			scrollList.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);		}		function mouseMoveHandler(event : MouseEvent) : void {			isMoving = true;			if (scrollBar.alpha < 1) {				TweenMax.killTweensOf(scrollBar);				if (scrollList.height > scrollMask.height) {					TweenMax.to(scrollBar, .5, {alpha:1});				} else {					scrollBar.alpha = 0;				}			}			var newY : Number = this.mouseY - yOffset;			// if scrollList's position exceeds the bounds, make it drag only half as far with each mouse movement (like iPhone/iPad behavior)			if (newY > bounds.top) {				scrollList.y = (newY + bounds.top) * 0.5;			} else if (newY < bounds.top - yOverlap) {				scrollList.y = (newY + bounds.top - yOverlap) * 0.5;			} else {				scrollList.y = newY;			}			var t : uint = getTimer();			// if the frame rate is too high, we won't be able to track the velocity as well, so only update the values 20 times per second			if (t - t2 > 50) {				y2 = y1;				t2 = t1;				y1 = scrollList.y;				t1 = t;			}			// test for finger location. If we drag outside the bounds, dispatch a mouse up event.			if (this.mouseY < scrollMask.y || this.mouseY > bounds.height + scrollMask.y || this.mouseX < scrollMask.x || this.mouseX > bounds.width + scrollMask.x) {				scrollList.stage.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));			}			// we need to update the scrollbar when dragging			updateBar();		}		public function startTouchTimer(e : MouseEvent) : void {			mouseDownY = stage.mouseY;			selectedButton = ScrollListItem(e.target);			// trace(e.target.name);			touchTimer.addEventListener(TimerEvent.TIMER, onListTimer, false, 0, true);			touchTimer.start();		}		public function stopTouchTimer() : void {			touchTimer.removeEventListener(TimerEvent.TIMER, onListTimer);			touchTimer.stop();		}		function onListTimer(e : Event) : void {			touchTimer.removeEventListener(TimerEvent.TIMER, onListTimer);			touchTimer.stop();			mouseUpY = stage.mouseY;			// drag down			if (mouseDownY < mouseUpY) {				if ((mouseUpY - mouseDownY) < tolerance) {					selectedButton.selectItem();				}			} else { // drag up				if ((mouseDownY - mouseUpY) < tolerance) {					selectedButton.selectItem();				}			}		}		function mouseUpHandler(event : MouseEvent) : void {			scrollList.stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			scrollList.stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			var time : Number = (getTimer() - t2) / 1000;			var yVelocity : Number = (scrollList.y - y2) / time;			ThrowPropsPlugin.to(scrollList, {throwProps:{y:{velocity:yVelocity, max:bounds.top, min:bounds.top - yOverlap, resistance:300}}, ease:Strong.easeOut, onUpdate:updateBar, onComplete:stoppedMoving}, 1, 0.3, 1);		}		function refreshScrollBar(newHeight : Number) : void {			// set to a minimum value of 4 to match iOS			if (newHeight > 4) {				scrollBar.graphics.clear();				scrollBar.graphics.beginFill(0x505050, .8);				scrollBar.graphics.drawRoundRect(0, 0, 4, (newHeight), 6, 6);				scrollBar.graphics.endFill();			}		}		function updateBar() {			scrollBar.y = (scrollList.y / listEndY) * barMaxDistance;			if (scrollBar.y > barMaxDistance) {				refreshScrollBar(scrollBarHeight - ((scrollBar.y + scrollBarHeight) - scrollMask.height));			}			// pulling down			if (scrollBar.y < 1) {				scrollBar.y = 0;				refreshScrollBar(scrollBarHeight - (scrollList.y / 2));			}		}		function stoppedMoving() : void {			TweenMax.killTweensOf(scrollBar);			TweenMax.to(scrollBar, .5, {alpha:0});			isMoving = false;		}		function setupList(container : Sprite, bounds : Rectangle, sprites : Array) : void {			// apply a solid background if required.			bg = new Sprite();			MemoryTracker.track(bg, "list bg");// remove when done testing			bg.graphics.beginFill(0xFFFFFF, 1);			bg.graphics.drawRect(0, 0, bounds.width, bounds.height);			bg.graphics.endFill();			bg.x = bounds.x;			bg.y = bounds.y;			// addChildAt(bg, 0);			for (var i : int = 0; i < sprites.length; i++) {				// width, height, scrollList that the items belong to//				var item : ScrollListItem = new ScrollListItem(_w, _itemh, this, _defaultcol, _hicol);//				MemoryTracker.track(item, "list item " + i);// remove when done testing////				item.name = "Item " + (i + 1);//				item.y = i * item.height;//				item.tf.text = "Item " + (i + 1)			container.addChild(sprites[i]);			}			scrollMask = new Shape();			scrollMask.graphics.beginFill(0xFF0033, 1);			scrollMask.graphics.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);			scrollMask.graphics.endFill();			container.parent.addChild(scrollMask);			container.mask = scrollMask;			// calculate the maximum Y value that the scrollList needs to move			listEndY = scrollMask.height - scrollList.height;			createScrollBar();		};		protected function redrawList() : void {			for (var i : int = 0; i < scrollList.numChildren; i++) {				var item : DisplayObject = scrollList.getChildAt(i);				item.y = i * item.height;			}			listEndY = scrollMask.height - scrollList.height;			createScrollBar();			TweenMax.to(scrollList, 1, {y:0, ease:Back.easeOut});		}		public function removeListItem(ind : int) : void {			// removing the item calls the destroy function			// we -1 due to the array of items starting at 0			scrollList.removeChildAt(ind - 1);			redrawList();		}		public function addListItem(ind : int) : void {			// we -1 due to the array of items starting at 0			var item : ScrollListItem = new ScrollListItem(_w, _itemh, this, _defaultcol, _hicol);			MemoryTracker.track(item, "list newitem ");// remove when done testing			item.name = "New Item " + ind;			item.tf.text = "New Item " + ind			scrollList.addChildAt(item, ind - 1);			redrawList();		}		// Clear the list of all items.		private function removeList() : void {			while (scrollList.numChildren > 0) {				scrollList.removeChildAt(0);			}		}		public function destroy() : void {			trace("destroy list");			removeList();			touchTimer = null;			bounds = null;			removeChild(scrollList);			scrollList.mask = null;			scrollList = null;			scrollMask.parent.removeChild(scrollMask);			scrollMask = null;			removeChild(scrollBar);			scrollBar = null;			selectedButton = null;			removeChild(bg);			bg = null;		}		public function addItem(stehlampeDevice : DeviceMenuButton) : void {			setupList(scrollList, bounds, [stehlampeDevice])		}	}}